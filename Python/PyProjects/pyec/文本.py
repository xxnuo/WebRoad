# -*- coding:utf-8 -*-
import re,socket,random,struct,datetime,json,html
from pypinyin import Style, pinyin  # 需要安装拼音库 pypinyin
from .共用 import *


@异常检测
def 文本_html字符解析(文本):
    '将&amp;这类字符转化成&'
    return html.unescape(文本)


@异常检测
def 文本_取左边(原文本, 要取出的数量):
    return 原文本[0:要取出的数量]


@异常检测
def 文本_取右边(原文本, 要取出的数量):
    return 原文本[len(原文本) - 要取出的数量:len(原文本)]


@异常检测
def 文本_取文本左边(原文本, 指定的文本):
    if 原文本.find(指定的文本) != -1:
        return 原文本[0:原文本.find(指定的文本)]
    else:
        return ''


@异常检测
def 文本_取文本右边(原文本, 指定的文本):
    if 原文本.find(指定的文本) != -1:
        return 原文本[原文本.rfind(指定的文本) + len(指定的文本):len(原文本)]
    else:
        return ''


@异常检测
def 文本_JSON解析(内容,中文解码=False):
    r'返回解析后的json文本，带\uxxxx的汉字可以使用 中文解码'
    return json.dumps(内容,ensure_ascii=not 中文解码)


@异常检测
def 文本_寻找文本(原文本, 寻找的文本, 开始的位置=0, 结束的位置=0):
    '成功返回所在位置,位置从0开始'
    return 原文本.find(寻找的文本, 开始的位置, 结束的位置)


@异常检测
def 文本_倒找文本(原文本, 寻找的文本, 开始的位置=0, 结束的位置=0):
    '类似于 find() 方法，不过是从右边开始查找'
    return 原文本.rfind(寻找的文本, 开始的位置, 结束的位置)


@异常检测
def 文本_取出中间文本(原文本, 前面的文本, 后面的文本, 开始的位置=0):
    位置_前 = 原文本.find(前面的文本, 开始的位置)
    位置_后 = 原文本.find(后面的文本, 位置_前 + len(前面的文本))
    if 位置_前 != -1 and 位置_后 != -1:
        return 原文本[位置_前 + len(前面的文本):位置_后]
    else:
        return ''


@异常检测
def 文本_倒取出中间文本(原文本, 右边的文本, 左边的文本, 开始的位置=-1):
    位置_右 = 原文本[:开始的位置].rfind(右边的文本)
    位置_左 = 原文本[:位置_右].rfind(左边的文本)
    if 位置_右 != -1 and 位置_左 != -1:
        return 原文本[位置_左 + len(左边的文本):位置_右]
    else:
        return ''


@异常检测
def 文本_取中间_批量(原文本, 前面的文本, 后面的文本):
    搜索位置 = 0
    列表 = []
    while True:
        搜索位置 = 原文本.find(前面的文本, 搜索位置)
        if 搜索位置 != -1:
            后面的位置 = 原文本.find(后面的文本, 搜索位置 + len(前面的文本))
            if 后面的位置 != -1:
                搜索位置 = 搜索位置 + len(前面的文本)
                取出的文本 = 原文本[搜索位置:后面的位置]
                if len(取出的文本) > 0:
                    列表.append(取出的文本)
            else:
                break
        else:
            break
    return 列表


@异常检测
def 文本_子文本替换(原文本, 要替换的文本, 用作替换的文本, 替换的次数=-1):
    return 原文本.replace(要替换的文本, 用作替换的文本, 替换的次数)


@异常检测
def 文本_分割文本(原文本, 分割标识, 分割次数=-1):
    """如果分割次数被指定，则返回分割次数+1的列表，后面的不做分割在最后一个列表里
    如：文本_分割文本("1-1-1-1",'-',2) 返回 ['1','1','1-1']
    """
    return 原文本.split(分割标识, 分割次数)


@异常检测
def 文本_换行分割(原文本, 保留换行=False):
    '以换行符做分割(\r,\n,\r\n)，可设置分割后是否保留换行符'
    return 原文本.splitlines(保留换行)


@异常检测
def 文本_到小写(原文本):
    return 原文本.casefold()



def 文本_到大写(原文本):
    return 原文本.upper()


@异常检测
def 文本_首字母转大写(原文本):
    return 原文本.capitalize()


@异常检测
def 文本_字符转小写(原文本):
    '可以处理a-z以外的转换,一般情况下两个转小写没啥区别'
    return 原文本.lower()


@异常检测
def 文本_是否有汉字(原文本):
    zhmodel = re.compile(u'[\u4e00-\u9fa5]')  # 检查中文
    match = zhmodel.search(原文本)
    if match:
        return True
    else:
        return False


@异常检测
def 文本_是否全汉字(原文本):
    '全汉字返回True'
    zhmodel = re.compile(u'[^\u4e00-\u9fa5]')  # 检查中文
    match = zhmodel.search(原文本)
    if match:
        return False
    else:
        return True


@异常检测
def 文本_匹配数字(原文本):
    '返回文本中的所有数字'
    结果 = re.findall(r'\d+',原文本)
    if 结果:
        return "".join(结果)


@异常检测
def 文本_匹配小写字母(原文本):
    '返回文本中的所有小写字母'
    结果 = re.findall(r'[a-z]+',原文本)
    if 结果:
        return "".join(结果)


@异常检测
def 文本_匹配大写字母(原文本):
    '返回文本中的所有大写字母'
    结果 = re.findall(r'[A-Z]+',原文本)
    if 结果:
        return "".join(结果)


@异常检测
def 文本_匹配字母(原文本):
    '返回文本中的所有字母'
    结果 = re.findall(r'[a-zA-Z]+',原文本)
    if 结果:
        return "".join(结果)


@异常检测
def 文本_匹配手机号码(原文本):
    '匹配文本中的手机号码,列表格式'
    结果 = re.findall(r"1[3,4,5,6,7,8,9]\d{9}", 原文本)
    if 结果:
        return 结果


@异常检测
def 文本_匹配IP地址(原文本):
    '匹配文本中的IP地址,列表格式'
    结果 = re.findall(r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}", 原文本)
    if 结果:
        return 结果

@异常检测
def 文本_匹配电话号码(原文本):
    '匹配文本中的电话号码,列表格式'
    结果 = re.findall(r"\d{3,4}[\s,-]?\d{7,8}", 原文本)
    if 结果:
        return 结果


@异常检测
def 文本_匹配QQ号码(原文本):
    '匹配文本中的QQ号码,列表格式,最多匹配11位数QQ号'
    结果 = re.findall(r"[1-9][0-9]{4,10}", 原文本)
    if 结果:
        return 结果


@异常检测
def 文本_匹配邮政编码(原文本):
    '中国邮政编码为6位数字,列表格式'
    结果 = re.findall(r"[1-9]\d{5}(?!\d)", 原文本)
    if 结果:
        return 结果


@异常检测
def 文本_匹配身份证号码(原文本):
    '中国的身份证为15位或18位,列表格式'
    结果 = re.findall(r"[1-9][0-9,X]{14,17}", 原文本)
    if 结果:
        return 结果


@异常检测
def 文本_匹配汉字(原文本):
    '返回文本中的所有汉字'
    结果 = re.findall(r"[\u4e00-\u9fa5]", 原文本)
    return "".join(结果)


@异常检测
def 文本_匹配双字节字符(原文本):
    '汉字 大写符号是双字节 数字 字母 小写符号是单字节字符'
    结果 = re.findall(r"[^\x00-\xff]", 原文本)
    return "".join(结果)


@异常检测
def 文本_匹配网址(原文本):
    '匹配带：//的网址,列表格式'
    结果 = re.findall(r"[a-zA-z]+://[^\s]*", 原文本)
    if 结果:
        return 结果


@异常检测
def 文本_匹配IP跟端口(原文本):
    '匹配IP地址带端口号,如：127.0.0.1:8080'
    结果 = re.findall(r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{2,5}", 原文本)
    if 结果:
        return 结果


@异常检测
def 文本_匹配邮箱号码(原文本):
    '匹配邮箱号码,列表格式'
    结果 = re.findall(r"[a-z0-9\.\-+_]{1,30}@[a-z0-9\.\-+_]{1,30}\.[a-z]{1,10}", 原文本)
    if 结果:
        return 结果


@异常检测
def 文本_账号是否合法(原文本):
    '匹配帐号是否合法(字母开头，允许6-16字节，允许字母数字下划线)'
    return re.match(r"^[a-zA-Z][a-zA-Z0-9_]{5,15}$",原文本)


@异常检测
def 文本_密码是否合法(原文本):
    '密码正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。'
    return re.match(r"^[a-zA-Z]\w{5,17}$",原文本)


@异常检测
def 文本_是否正整数(原文本):
    return re.match(r"^[1-9]\d*$",原文本)


@异常检测
def 文本_是否负整数(原文本):
    return re.match(r"^-[1-9]\d*$",原文本)


@异常检测
def 文本_是否整数(原文本):
    return re.match(r"^-?[1-9]\d*$",原文本)


@异常检测
def 文本_是否非正整数(原文本):
    return re.match(r"^-[1-9]\d*|0$",原文本)


@异常检测
def 文本_是否非负整数(原文本):
    return re.match(r"^[1-9]\d*|0$",原文本)


@异常检测
def 文本_是否正小数(原文本):
    return re.match(r"^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$",原文本)


@异常检测
def 文本_是否负小数(原文本):
    return re.match(r"^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$",原文本)


@异常检测
def 文本_是否小数(原文本):
    return re.match(r"^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$",原文本)


@异常检测
def 文本_是否非正小数(原文本):
    return re.match(r"^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$",原文本)


@异常检测
def 文本_是否非负小数(原文本):
    return re.match(r"^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$",原文本)


@异常检测
def 文本_是否为IP地址(IP):
    return re.match(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$",IP)


@异常检测
def 文本_大小写翻转(原文本):
    return 原文本.swapcase()


@异常检测
def 文本_是否全大写(原文本):
    return 原文本.isupper()


@异常检测
def 文本_是否全小写(原文本):
    return 原文本.islower()


@异常检测
def 文本_是否全字母(原文本):
    return 原文本.isalpha()


@异常检测
def 文本_是否全数字字母(原文本):
    return 原文本.isalnum()


@异常检测
def 文本_是否全数字(原文本):
    return 原文本.isdigit()


@异常检测
def 文本_取出现次数(原文本, 欲查询的文本, 开始的位置=0, 结束的位置=0):
    结束的位置 = len(原文本) if 结束的位置 < 1 else 结束的位置
    return 原文本.count(欲查询的文本, 开始的位置, 结束的位置)


@异常检测
def 文本_是否标题化(原文本):
    '返回True,False,如果字符串是标题化（所有的单词都是以大写开始，其余字母均小写），则返回 True，否则返回 False'
    return 原文本.istitle()


@异常检测
def 文本_标题化(原文本):
    '返回标题化（所有的单词都是以大写开始，其余字母均小写）的字符串'
    return 原文本.title()


@异常检测
def 文本_取文本长度(原文本):
    '不限于取文本长度'
    return len(原文本)


@异常检测
def 文本_是否全空格(原文本):
    return 原文本.isspace()


@异常检测
def 文本_删左边全部空格(原文本):
    return 原文本.lstrip()


@异常检测
def 文本_删右边全部空格(原文本):
    return 原文本.rstrip()


@异常检测
def 文本_删全部空格(原文本):
    '就是文本替换'
    return 原文本.replace(" ", "")


@异常检测
def 文本_删首尾指定字符(原文本, 欲删除的内容=' '):
    return 原文本.strip(欲删除的内容)


@异常检测
def 文本_填充空格_居中(原文本, 填充目标长度=0):
    '将文本用空格填充到指定长度使原文本居中'
    return 原文本.center(填充目标长度)


@异常检测
def 文本_填充空格_左对齐(原文本, 填充目标长度=0):
    '将文本用空格填充到指定长度使原文本左对齐'
    return 原文本.ljust(填充目标长度)


@异常检测
def 文本_填充空格_右对齐(原文本, 填充目标长度=0):
    '将文本用空格填充到指定长度使原文本右对齐'
    return 原文本.rjust(填充目标长度)


@异常检测
def 文本_填充0_右对齐(原文本, 填充目标长度=0):
    '将文本用0填充到指定长度使原文本右对齐,如：0001'
    return 原文本.zfill(填充目标长度)


@异常检测
def 文本_拼接(连接符, 欲拼接的序列):
    return 连接符.join(欲拼接的序列)


@异常检测
def 文本_按键名转键值(按键名):
    "传入按键名 如 A  或者1  2 3  返回整数的键值"
    return ord(按键名)


@异常检测
def 文本_键值转按键名(键值):
    '传入整数的键值 返回对应键值的键符'
    return chr(键值)


@异常检测
def 文本_是否指定文本结尾(原文本, 结尾的文本, 开始的位置=0, 结束的位置=0):
    '如果字符串为指定的后缀返回True，否则返回False'
    结束的位置 = len(原文本) if 结束的位置 < 1 else 结束的位置
    return 原文本.endswith(结尾的文本, 开始的位置, 结束的位置)


@异常检测
def 文本_是否指定文本开头(原文本, 开头的文本, 开始的位置=0, 结束的位置=0):
    '如果字符串为指定的开头返回True，否则返回False'
    结束的位置 = len(原文本) if 结束的位置 < 1 else 结束的位置
    return 原文本.startswith(开头的文本, 开始的位置, 结束的位置)


@异常检测
def 文本_TAB转空格(原文本, 转换的数量=8):
    '把字符串中的 tab 符号（\t）转换为空格，如不指定参数，默认的空格数是 tabsize=8'
    return 原文本.expandtabs(tabsize=转换的数量)


@异常检测
def 文本_三元分割_左(原文本, 分割标识):
    '将字符串分割成三元元组，存放分割的前面，分割标识本身，分割的后面'

    return 原文本.partition(分割标识)


@异常检测
def 文本_三元分割_右(原文本, 分割标识):
    '类似于 partition() 方法，不过是从右边开始查找'
    return 原文本.rpartition(分割标识)



def 文本_取随机IP():
    return socket.inet_ntoa(struct.pack('>I', random.randint(1, 0xffffffff)))

@异常检测
def 文本_取随机数字(取出的数量=1, 是否排除0开头=False):
    取出的数量 = 1 if 取出的数量 < 1 else 取出的数量
    文本 = ''
    if 是否排除0开头 == False:
        for x in range(取出的数量):
            文本 += str(random.randint(0, 9))
    else:
        文本 +=  str(random.randint(1, 9))
        for x in range(取出的数量 - 1):
            文本 += str(random.randint(0, 9))
    return 文本


@异常检测
def 文本_取随机范围数字(最小值, 最大值, 是否返回整数=False):
    '如果设置返回整数则返回int类型'
    if int(最小值) > int(最大值):#如果反了就倒过来
        最小值,最大值 = 最大值,最小值
    if 是否返回整数 == False:
        return str(random.randint(int(最小值), int(最大值)))
    else:
        return random.randint(int(最小值), int(最大值))


@异常检测
def 文本_取随机字母(取出的数量=1, 类型=0):
    '类型：0.小写 1.大写 2.混合'
    取出的数量 = 1 if 取出的数量 < 1 else 取出的数量
    类型 = 0 if 类型 < 0 or 类型 > 2 else 类型
    字母 = 'abcdefghijklnmopqrstuvwxyz'
    文本 = ''
    if 类型 == 0:
        for x in range(取出的数量):
            文本 += random.choice(字母)
    elif 类型 == 1:
        for x in range(取出的数量):
            文本 += random.choice(字母).upper()
    else:
        for x in range(取出的数量):
            随机数 = random.randint(0, 1)
            if 随机数 == 1:
                文本 += random.choice(字母)
            else:
                文本 += random.choice(字母).upper()
    return 文本


@异常检测
def 文本_取随机字符(取出的数量=1):
    '包括0-9 a-z A-Z'
    取出的数量 = 1 if 取出的数量 < 1 else 取出的数量
    字符 = '0123456789abcdefghijklnmopqrstuvwxyzABCDEFGHIJKLNMOPQRSTUVWXYZ'
    文本 = ''
    for x in range(取出的数量):
        文本 += random.choice(字符)
    return 文本


@异常检测
def 文本_取随机汉字(取出的数量=1):
    '部分常见汉字'
    取出的数量 = 1 if 取出的数量 < 1 else 取出的数量
    文本 = ''
    部分汉字 = "的一是了我不人在他有这个上们来到时大地为子中你说生国年着就那和要她出也得里后自以会家可下而过天去能对小多然于心学么之都好看起发当没成只如事把还用第样道想作种开美总从无情己面最女但现前些所同日手又行意动方期它头经长儿回位分爱老因很给名法间斯知世什两次使身者被高已亲其进此话常与活正感见明问力理尔点文几定本公特做外孩相西果走将月十实向声车全信重三机工物气每并别真打太新比才便夫再书部水像眼等体却加电主界门利海受听表德少克代员许稜先口由死安写性马光白或住难望教命花结乐色更拉东神记处让母父应直字场平报友关放至张认接告入笑内英军候民岁往何度山觉路带万男边风解叫任金快原吃妈变通师立象数四失满战远格士音轻目条呢病始达深完今提求清王化空业思切怎非找片罗钱紶吗语元喜曾离飞科言干流欢约各即指合反题必该论交终林请医晚制球决窢传画保读运及则房早院量苦火布品近坐产答星精视五连司巴奇管类未朋且婚台夜青北队久乎越观落尽形影红爸百令周吧识步希亚术留市半热送兴造谈容极随演收首根讲整式取照办强石古华諣拿计您装似足双妻尼转诉米称丽客南领节衣站黑刻统断福城故历惊脸选包紧争另建维绝树系伤示愿持千史谁准联妇纪基买志静阿诗独复痛消社算义竟确酒需单治卡幸兰念举仅钟怕共毛句息功官待究跟穿室易游程号居考突皮哪费倒价图具刚脑永歌响商礼细专黄块脚味灵改据般破引食仍存众注笔甚某沉血备习校默务土微娘须试怀料调广蜖苏显赛查密议底列富梦错座参八除跑亮假印设线温虽掉京初养香停际致阳纸李纳验助激够严证帝饭忘趣支春集丈木研班普导顿睡展跳获艺六波察群皇段急庭创区奥器谢弟店否害草排背止组州朝封睛板角况曲馆育忙质河续哥呼若推境遇雨标姐充围案伦护冷警贝著雪索剧啊船险烟依斗值帮汉慢佛肯闻唱沙局伯族低玩资屋击速顾泪洲团圣旁堂兵七露园牛哭旅街劳型烈姑陈莫鱼异抱宝权鲁简态级票怪寻杀律胜份汽右洋范床舞秘午登楼贵吸责例追较职属渐左录丝牙党继托赶章智冲叶胡吉卖坚喝肉遗救修松临藏担戏善卫药悲敢靠伊村戴词森耳差短祖云规窗散迷油旧适乡架恩投弹铁博雷府压超负勒杂醒洗采毫嘴毕九冰既状乱景席珍童顶派素脱农疑练野按犯拍征坏骨余承置臓彩灯巨琴免环姆暗换技翻束增忍餐洛塞缺忆判欧层付阵玛批岛项狗休懂武革良恶恋委拥娜妙探呀营退摇弄桌熟诺宣银势奖宫忽套康供优课鸟喊降夏困刘罪亡鞋健模败伴守挥鲜财孤枪禁恐伙杰迹妹藸遍盖副坦牌江顺秋萨菜划授归浪听凡预奶雄升碃编典袋莱含盛济蒙棋端腿招释介烧误乾坤"
    for x in range(取出的数量):
        文本 += random.choice(部分汉字)
    return 文本


@异常检测
def 文本_取随机姓氏(取常见姓氏=False):
    '常见姓氏为自己设置挑选的,仅做参考'
    百家姓 = """赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许何吕施张孔曹严华金魏陶姜戚谢邹喻柏水窦章云苏潘葛奚范彭郎鲁韦昌马苗凤花方俞任袁柳酆鲍史唐费廉岑薛雷贺倪汤滕殷罗毕郝邬安常乐于时傅皮卞齐康伍余元卜顾孟平黄和穆萧尹姚邵湛汪祁毛禹狄米贝明臧计伏成戴谈宋茅庞熊纪舒屈项祝董梁杜阮蓝闵席季麻强贾路娄危江童颜郭梅盛林刁钟徐邱骆高夏蔡田樊胡凌霍虞万支柯昝管卢莫柯房裘缪干解应宗丁宣贲邓郁单杭洪包诸左石崔吉钮龚程嵇邢滑裴陆荣翁荀羊于惠甄曲家封芮羿储靳汲邴糜松井段富巫乌焦巴弓牧隗山谷车侯宓蓬全郗班仰秋仲伊宫宁仇栾暴甘钭历戎祖武符刘景詹束龙叶幸司韶郜黎蓟溥印宿白怀蒲邰从鄂索咸籍赖卓蔺屠蒙池乔阳郁胥能苍双闻莘党翟谭贡劳逄姬申扶堵冉宰郦雍却璩桑桂濮牛寿通边扈燕冀浦尚农温别庄晏柴瞿阎充慕连茹习宦艾鱼容向古易慎戈廖庾终暨居衡步都耿满弘匡国文寇广禄阙东欧殳沃利蔚越夔隆师巩厍聂晁勾敖融冷訾辛阚那简饶空曾毋沙乜养鞠须丰巢关蒯相查后荆红游竺权逮盍益桓公"""
    常见百家姓 = '赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许何吕施张孔曹严华金魏陶姜戚谢邹喻柏水窦章云苏潘葛范彭郎鲁韦昌马苗凤花方俞任袁柳史唐费薛雷贺罗毕于齐萧尹姚顾孟平黄宋庞项祝董梁杜阮刘万丁石洪白田夏'
    if 取常见姓氏 == False:
        return random.choice(百家姓)
    else:
        return random.choice(常见百家姓)



def 文本_取随机手机号():
    号码前缀 = ['130', '131', '132', '134', '135', '136', '137', '138', '139', '147', '150', '151', '152', '153', '155',
            '156', '157', '158', '159', '170', '171', '180', '182', '183', '185', '186', '187', '188', '189']
    尾号 = ''
    for x in range(8):
        尾号 += str(random.randint(0, 9))
    return random.choice(号码前缀) + 尾号


def 文本_取随机邮箱():
    邮箱后缀 = ['@qq.com', '@sina.com', '@126.com', '@163.com', '@hotmail.com', '@139.com', '@189.com', '@sohu.com',
            '@21cn.com', '@189.com', '@tom.com', '@aol.com', '@263.com', '@aliyun.com', '@foxmail.com', '@yeah.net']
    字母 = 字符 = 混合 = ""
    数字 = str(random.randint(1, 9))
    for x in range(random.randint(5, 11)): 数字 += str(random.randint(0, 9))
    for x in range(random.randint(5, 11)): 字母 += random.choice('qwertyuiopasdfghjklzxcvbnm')
    for x in range(random.randint(6, 11)): 字符 += random.choice('0123456789abcdefghijklnmopqrstuvwxyz')
    for x in range(random.randint(1, 6)): 混合 += random.choice('qwertyuiopasdfghjklzxcvbnm')
    for x in range(random.randint(3, 10)): 混合 += str(random.randint(0, 9))
    字符 = 字符[1:] if 字符.startswith('0') else 字符
    return random.choice([混合,混合,混合,字母,数字,字符]) + random.choice(邮箱后缀)


@异常检测
def 文本_转时间_datetime(时间文本, 格式='%Y-%m-%d %H:%M:%S'):
    '把文本格式的时间转成datetime的时间格式，文本跟时间格式要匹配'
    return datetime.datetime.strptime(时间文本, 格式)


@异常检测
def 文本_汉字转拼音(原文本, 连接符='', 拼音风格=0, 遍历多音=False, 无拼音处理=0, 严格规范=False):
    '默认返回全拼,拼音风格:0是不带声调的全拼,1是带声调的全拼,2是取声母部分,3是取首字母,无拼音处理：0是保留原始字符,1是忽略该字符,2是 替换为去掉 \\u 的 unicode 编码字符串'
    风格 = [Style.NORMAL, Style.TONE, Style.INITIALS, Style.FIRST_LETTER]
    处理 = ['default','ignore','replace']
    rStyle = 风格[0 if 拼音风格 > 3 or 拼音风格 < 0 else 拼音风格]
    Errors = 处理[0 if 无拼音处理 > 2 or 无拼音处理 < 0 else 无拼音处理]

    拼音 = ''
    拼音列表 = pinyin(hans=原文本, style=rStyle, heteronym=遍历多音, errors=Errors, strict=严格规范)
    for x in 拼音列表:
        for i in x:
            拼音 += 连接符 + i
    return 拼音
